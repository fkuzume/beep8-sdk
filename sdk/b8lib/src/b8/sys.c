#include <beep8.h>
#include <stdio.h>
#include <b8/irq.h>
#include <b8/errno.h>
#include <sys/errno.h>

void  b8SysHalt(void){
  b8SysPuts( "b8SysHalt() has been called and the system will halt.\n");
  void* return_address = __builtin_return_address(0);
  b8SysPuts("Caller return address: 0x");
  b8SysPutHex((u32)return_address);
  b8SysPutCR();
  b8SysPuts("System is now halting. Please check the return address for debugging.\n");
  b8SysPuts("You can analyze this address using \nthe .map or .lst files generated by the application.\n");
  asm("hlt");
}

extern  void  b8rst(void);
void  b8SysReset(void){
  b8rst();
}

void  b8SysPuts(const char* str ){
  const char* pp = str;
  while( *pp ){
    B8_FIFO_SCI_TX(0) = (u32)*pp;
    ++pp;
  }
}

void  b8SysPutHex( u32 data ){
  for( s16 sft=28 ; sft>=0 ; sft-=4 ){
    B8_FIFO_SCI_TX(0) = "0123456789abcdef"[ (data >> sft) & 0xf ];
  }
}

void  b8SysPutNum( s32 data ){
  if( 0 == data ){
    b8SysPuts( "0" );
    return;
  }

  if( data < 0 ){
    b8SysPuts( "-" );
    data = -data;
  }

  char buff[16];
  buff[15] = 0x00;
  u8 up = 14;
  while( data > 0){
    buff[ up-- ] = '0' + (data%10);
    data /= 10;
  }
  b8SysPuts( &buff[up+1] );
}

void  b8SysPutCR(void){
  b8SysPuts( "\n" );
}

u32   b8SysGetCpuClock(void){
  return  B8_INF_CPUCLK;
}

static  u32       _irq_use_map = 0x00000000;
static  sem_t     _sem_irq_sync[ B8_IRQ_NUM_OF_INTERRUPTS ] = {0};
static  pthread_t _irq_thread  [ B8_IRQ_NUM_OF_INTERRUPTS ] = {0};

static  void* _b8SysIrqThread( void* arg ){
  sem_t* sem_irq = (sem_t*)arg;
  while(1){
    pthread_yield();
    sem_post( sem_irq );
  }
  return NULL;
}

static  void* _b8SysIrqThreadUndefinedInstruction( void* arg ){
  (void)arg;
  while(1){
    pthread_yield();
    b8SysPuts( "Caught undefined instruction\n" ); 
    b8SysHalt();
  }
  return NULL;
}

int b8SysIrqWait( u32 irq ){
  if(!( _irq_use_map & (1<<irq)) ){
    set_errno( EINVAL );
    return -1;
  }

  sem_t* sem = &(_sem_irq_sync[ irq ]);

  int sval=0;
  int ret = sem_getvalue(sem, &sval );
  if( ret < 0 ){
    set_errno( -ret );
    return -1;
  }
  if( sval > 1 )  printf( "sval=%d\n" , sval );

  return sem_wait( sem );
}

int b8SysIrqClearAndWait(u32 irq){
  if(!( _irq_use_map & (1u<<irq)) ){
    set_errno(EINVAL);
    return -1;
  }

  sem_t *sem = &_sem_irq_sync[irq];
  int sval;
  while( sem_getvalue(sem, &sval)==0 && sval > 0 ){
    sem_trywait(sem);
  }

  return sem_wait(sem);
}

int   b8SysSetupIrqWait( u32 irq ){
  if( irq >= B8_IRQ_NUM_OF_INTERRUPTS ){
    set_errno( EINVAL );
    return -1;
  }

  if( _irq_use_map & (1<<irq) ){
    return  B8_OS_OK;
  }

  int ret = sem_init( &_sem_irq_sync[ irq ] , 0, 0);
  if( ret < 0 ){
    set_errno( -ret );
    return -1;
  }

  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setschedpolicy(&attr,SCHED_IRQ);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  pthread_attr_setstacksize(&attr, 0x800);
  attr.irq_no = irq;
  if( irq == B8_IRQ_UNDF ){
    ret = pthread_create( &_irq_thread[irq] , &attr, _b8SysIrqThreadUndefinedInstruction, &_sem_irq_sync[ irq ] );
  } else { 
    ret = pthread_create( &_irq_thread[irq] , &attr, _b8SysIrqThread, &_sem_irq_sync[ irq ] );
  }
  if( ret > 0 ){
    set_errno( ret );
    return -1;
  }

  _irq_use_map |= 1<<irq;
  return  0;
}
